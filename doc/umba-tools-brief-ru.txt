umba-brief-scanner

    Производит сканирование заданных каталогов на предмет поиска файлов по маске (include/exclude files)
    В каждом файле производит поиск коментария специального вида:
        /*(*|!) (\|@)file
          (\|@)brief Brief desription of the file
        */
    --update[=FILE] позволяет подсасывать из предыдущего файла

    Производится поиск entry points типа main/DllMain/etc, --entry-name=... задает имя и тип возвращаемых значений

    --main - генерировать только entry points в отчёте.

    --update[=FILE] - в выходном txt файле можно дописывать описания файлов, и если оно не появляется в сорцах
      - берётся из предыдущей версии brief-файла

    --split-group - группирует/делит на группы


umba-enum-gen

    Генератор enum'ов. На входе - задаём имена абы как, хоть в параметре командной строки, хоть в .rsp файле, 
    на выходе - отформатированно по всем правилам - PascalCase, camelCase etc.
    Сериализация и десериализация значений, как и наборов значений, enum-флаги, для флагов - bitwise операторы.
    Шаблоны для генерации - user/custom/base (builtins) варианты для lang/template версий.
    Автоматически производится поиск файла с опциями 'umba-enum-gen-flags.txt', который обрабатывается
    после встроенных файлов опций, но перед всеми непосредственно указанными опциями.


umba-make-headers

    Простая утилита.
    Генерирует include файлы согласно namelist.txt (который пишется руками), со ссылкой на C++/Qt документацию.
    Сгенерированное надо подсовывать среде, которая умеет в это.
    std::back_inserter лежит в <iterator>, но помнить это никто не делает.
    Просто пишем в среде '#include "std/ba' - среда подсказывает, '#include "std/back_inserter'
    В свою очередь, в файле 'std/back_inserter' лежит #include на <iterator>, и коментарий со ссылкой на cppreference
    (или на кутишные доки).
    Ссылка на доку в 95% случаев работает.
    Готовченко тут:
    https://github.com/al-martyn1/_std_headers
    https://github.com/al-martyn1/_qt_headers
    https://github.com/al-martyn1/_qt5_headers
    https://github.com/al-martyn1/_qt6_headers
    Примеры namelist.txt там же, для каждого случая.


umba-pretty-headers

    Парсит заданные входные файлы, для каждого типа или свободной функции или дефайна создаёт include-файл в output каталоге.
    Развитие утилиты umba-make-headers. Используется Clang-tooling. Текущая версия Win32/64 собрана на MSVC2019,
    если студия нужной версии/Clang не установлены, то могут быть проблемы (проблемы могут быть, даже если всё в 
    порядке вроде бы - как решать - хз, но у меня работает, на предыдущей работе не работало, но я уволился)
    Неплоха, чтобы посмотреть, что вообще в проекте с типами и иерархиями имен и их пространств творится, и что есть что.


umba-sort-headers

   Сортировка incude'ов. Ничего не трогает, в тч кодировку. Макс попортятся переводы строк, но и тут мы старались делать нежно.
   Пробелы и пустые строки игнорируются. Все иное, в тч пустой комент - это брик для сорта иклудов, 
   инклуды сортируются только в рамках блока без бриков. Всякие #ifdef'ы - тоже брики.
   Можно задавать приоритет сортировки - "user" и <system>
   Хорошая практика - в хидере сортировать всё, в файле реализации - первым идёт его хидер (чтобы проверить его самододостаточность),
   затем - отсортированные внешние зависимости - чтобы проще ориентироваться.


umba-subst-macros

   Задаём макросы в командной строке. Парсим файл, подставляем - профит. Макросы похожи на макросы VisualStudio - $(MacroName).
   Неизвестные макросы можно пропускать как есть, либо вырезать.
   Ключик --raw позоляет делать замены без макросов - тупая текстовая подстановка. Из конкретного файла делаем шаблон, потом шаблон
   используем для генерации по шаблону при помощи макросов. Профит.


umba-tabtool

   --check - только проверки
   конвертит TAB'ы в пробелы и наоборот
   нормализация TAB'ов - конвертит пробелы в TAB'ы, потом наоборот, потом опять наоборот, с учетом TAB-дельты.



